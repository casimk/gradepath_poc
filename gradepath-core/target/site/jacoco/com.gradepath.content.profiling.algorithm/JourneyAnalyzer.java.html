<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JourneyAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">content-service</a> &gt; <a href="index.source.html" class="el_package">com.gradepath.content.profiling.algorithm</a> &gt; <span class="el_source">JourneyAnalyzer.java</span></div><h1>JourneyAnalyzer.java</h1><pre class="source lang-java linenums">package com.gradepath.content.profiling.algorithm;

import com.gradepath.content.recommendation.profile.BehavioralProfile;
import com.gradepath.content.recommendation.profile.BehavioralProfile.ContentTransition;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Analyzes content journey patterns using Markov chains.
 * Ported from TypeScript JourneyAnalyzer.
 *
 * Features:
 * - Tracks content transitions (Markov chain)
 * - Calculates transition probabilities
 * - Identifies common paths
 * - Tracks topic diversity per user
 * - Predicts next likely content
 */
@Component
<span class="fc" id="L24">@Slf4j</span>
<span class="fc" id="L25">public class JourneyAnalyzer {</span>

    // Track transitions for Markov chain: fromContent -&gt; (toContent -&gt; frequency)
<span class="fc" id="L28">    private final Map&lt;String, Map&lt;String, Integer&gt;&gt; transitions = new ConcurrentHashMap&lt;&gt;();</span>

    // Track unique topics per user for diversity calculation
<span class="fc" id="L31">    private final Map&lt;String, Set&lt;String&gt;&gt; userTopics = new ConcurrentHashMap&lt;&gt;();</span>

    private static final int MIN_FREQUENCY_THRESHOLD = 2;
    private static final int MAX_COMMON_PATHS = 20;
    private static final int TOP_NEXT_PREDICTIONS = 3;

    /**
     * Analyze a journey event and update profile
     */
    public void analyzeJourney(BehavioralProfile profile, InterestScorer.RawJourneyEvent event) {
<span class="fc" id="L41">        String userId = event.userId();</span>
<span class="fc" id="L42">        String contentId = event.contentId();</span>
<span class="fc" id="L43">        String previousContentId = event.previousContentId();</span>
<span class="fc" id="L44">        List&lt;String&gt; topicTags = event.topicTags();</span>

<span class="fc bfc" id="L46" title="All 2 branches covered.">        if (topicTags == null) {</span>
<span class="fc" id="L47">            topicTags = List.of();</span>
        }

        // Track topic diversity
<span class="fc" id="L51">        userTopics.computeIfAbsent(userId, k -&gt; ConcurrentHashMap.newKeySet())</span>
<span class="fc" id="L52">                  .addAll(topicTags);</span>

        // Update unique topic ratio in engagement
<span class="fc" id="L55">        Set&lt;String&gt; userTopicSet = userTopics.get(userId);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        if (profile.getTotalContentConsumed() &gt; 0) {</span>
<span class="fc" id="L57">            double uniqueTopicRatio = (double) userTopicSet.size() /</span>
<span class="fc" id="L58">                                     Math.max(profile.getTotalContentConsumed(), 1);</span>

<span class="fc" id="L60">            var engagement = profile.getEngagement();</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            if (engagement != null) {</span>
<span class="fc" id="L62">                engagement.setUniqueTopicRatio(uniqueTopicRatio);</span>
            }
        }

        // Track content transitions for path analysis
<span class="pc bpc" id="L67" title="1 of 4 branches missed.">        if (previousContentId != null &amp;&amp; !previousContentId.isEmpty()) {</span>
<span class="fc" id="L68">            trackTransition(previousContentId, contentId);</span>
<span class="fc" id="L69">            updateCommonPaths(profile);</span>
        }
<span class="fc" id="L71">    }</span>

    /**
     * Track a content transition for Markov chain analysis
     */
    private void trackTransition(String from, String to) {
<span class="fc" id="L77">        transitions.computeIfAbsent(from, k -&gt; new ConcurrentHashMap&lt;&gt;())</span>
<span class="fc" id="L78">                  .merge(to, 1, Integer::sum);</span>
<span class="fc" id="L79">    }</span>

    /**
     * Update common paths in profile based on transition frequencies
     */
    private void updateCommonPaths(BehavioralProfile profile) {
<span class="fc" id="L85">        List&lt;ContentTransition&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L87">        transitions.forEach((fromContent, toMap) -&gt; {</span>
<span class="fc" id="L88">            int totalFrom = toMap.values().stream().mapToInt(Integer::intValue).sum();</span>

<span class="fc" id="L90">            toMap.forEach((toContent, frequency) -&gt; {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                if (frequency &gt;= MIN_FREQUENCY_THRESHOLD) {</span>
<span class="fc" id="L92">                    result.add(ContentTransition.builder()</span>
<span class="fc" id="L93">                        .fromContent(fromContent)</span>
<span class="fc" id="L94">                        .toContent(toContent)</span>
<span class="fc" id="L95">                        .frequency(frequency)</span>
<span class="fc" id="L96">                        .probability((double) frequency / totalFrom)</span>
<span class="fc" id="L97">                        .build());</span>
                }
<span class="fc" id="L99">            });</span>
<span class="fc" id="L100">        });</span>

        // Sort by frequency and keep top paths
<span class="fc" id="L103">        List&lt;ContentTransition&gt; sorted = result.stream()</span>
<span class="fc" id="L104">            .sorted((a, b) -&gt; Integer.compare(b.getFrequency(), a.getFrequency()))</span>
<span class="fc" id="L105">            .limit(MAX_COMMON_PATHS)</span>
<span class="fc" id="L106">            .collect(Collectors.toList());</span>

<span class="fc" id="L108">        profile.setCommonPaths(sorted);</span>
<span class="fc" id="L109">    }</span>

    /**
     * Predict next likely content items based on current content
     */
    public List&lt;String&gt; predictNext(String currentContent) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (currentContent == null) {</span>
<span class="fc" id="L116">            return List.of();</span>
        }

<span class="fc" id="L119">        Map&lt;String, Integer&gt; fromMap = transitions.get(currentContent);</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">        if (fromMap == null || fromMap.isEmpty()) {</span>
<span class="fc" id="L121">            return List.of();</span>
        }

<span class="fc" id="L124">        return fromMap.entrySet().stream()</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            .filter(e -&gt; e.getValue() &gt;= MIN_FREQUENCY_THRESHOLD)</span>
<span class="fc" id="L126">            .sorted((a, b) -&gt; Integer.compare(b.getValue(), a.getValue()))</span>
<span class="fc" id="L127">            .limit(TOP_NEXT_PREDICTIONS)</span>
<span class="fc" id="L128">            .map(Map.Entry::getKey)</span>
<span class="fc" id="L129">            .collect(Collectors.toList());</span>
    }

    /**
     * Get the transition matrix (for debugging/analysis)
     */
    public Map&lt;String, Map&lt;String, Integer&gt;&gt; getTransitionMatrix() {
<span class="fc" id="L136">        return Collections.unmodifiableMap(transitions);</span>
    }

    /**
     * Get topics tracked for a user
     */
    public Set&lt;String&gt; getUserTopics(String userId) {
<span class="fc" id="L143">        return Collections.unmodifiableSet(userTopics.getOrDefault(userId, Set.of()));</span>
    }

    /**
     * Clear transition data (useful for testing)
     */
    public void clearTransitions() {
<span class="fc" id="L150">        transitions.clear();</span>
<span class="fc" id="L151">    }</span>

    /**
     * Clear user topics (useful for testing)
     */
    public void clearUserTopics() {
<span class="fc" id="L157">        userTopics.clear();</span>
<span class="fc" id="L158">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>