<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecommendationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">content-service</a> &gt; <a href="index.source.html" class="el_package">com.gradepath.content.recommendation.service</a> &gt; <span class="el_source">RecommendationService.java</span></div><h1>RecommendationService.java</h1><pre class="source lang-java linenums">package com.gradepath.content.recommendation.service;

import com.gradepath.content.analytics.repository.ContentInteractionRepository;
import com.gradepath.content.content.model.Content;
import com.gradepath.content.content.repository.ContentRepository;
import com.gradepath.content.profile.model.User;
import com.gradepath.content.profile.model.UserPreferences;
import com.gradepath.content.profile.model.SkillLevel;
import com.gradepath.content.profile.repository.SkillLevelRepository;
import com.gradepath.content.profile.repository.UserPreferencesRepository;
import com.gradepath.content.profile.repository.UserRepository;
import com.gradepath.content.recommendation.model.Recommendation;
import com.gradepath.content.recommendation.repository.RecommendationRepository;
import com.gradepath.content.recommendation.profile.BehavioralProfileService;
import com.gradepath.content.recommendation.algorithm.SessionContextService;
import com.gradepath.content.recommendation.algorithm.ShortsStrategyService;
import com.gradepath.content.recommendation.algorithm.BanditStrategyService;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
<span class="fc" id="L31">@Slf4j</span>
public class RecommendationService {

    private final ContentScoringService scoringService;
    private final ContentRepository contentRepository;
    private final RecommendationRepository recommendationRepository;
    private final UserRepository userRepository;
    private final UserPreferencesRepository preferencesRepository;
    private final SkillLevelRepository skillLevelRepository;
    private final ContentInteractionRepository interactionRepository;
    private final BehavioralProfileService behavioralProfileService;
    private final SessionContextService sessionContextService;
    private final ShortsStrategyService shortsStrategyService;
    private final BanditStrategyService banditStrategyService;

    public RecommendationService(
            ContentScoringService scoringService,
            ContentRepository contentRepository,
            RecommendationRepository recommendationRepository,
            UserRepository userRepository,
            UserPreferencesRepository preferencesRepository,
            SkillLevelRepository skillLevelRepository,
            ContentInteractionRepository interactionRepository,
            BehavioralProfileService behavioralProfileService,
            SessionContextService sessionContextService,
            ShortsStrategyService shortsStrategyService,
<span class="fc" id="L57">            BanditStrategyService banditStrategyService) {</span>
<span class="fc" id="L58">        this.scoringService = scoringService;</span>
<span class="fc" id="L59">        this.contentRepository = contentRepository;</span>
<span class="fc" id="L60">        this.recommendationRepository = recommendationRepository;</span>
<span class="fc" id="L61">        this.userRepository = userRepository;</span>
<span class="fc" id="L62">        this.preferencesRepository = preferencesRepository;</span>
<span class="fc" id="L63">        this.skillLevelRepository = skillLevelRepository;</span>
<span class="fc" id="L64">        this.interactionRepository = interactionRepository;</span>
<span class="fc" id="L65">        this.behavioralProfileService = behavioralProfileService;</span>
<span class="fc" id="L66">        this.sessionContextService = sessionContextService;</span>
<span class="fc" id="L67">        this.shortsStrategyService = shortsStrategyService;</span>
<span class="fc" id="L68">        this.banditStrategyService = banditStrategyService;</span>
<span class="fc" id="L69">    }</span>

    /**
     * Get recommendations for a user with caching
     */
    @Cacheable(value = &quot;recommendations&quot;, key = &quot;#userId&quot;)
    public List&lt;RecommendationResponse&gt; getRecommendations(UUID userId, int limit) {
<span class="nc" id="L76">        log.info(&quot;Generating TikTok-style recommendations for user: {}, limit: {}&quot;, userId, limit);</span>

        // Get user profile and preferences
<span class="nc" id="L79">        User user = userRepository.findById(userId)</span>
<span class="nc" id="L80">            .orElseThrow(() -&gt; new IllegalArgumentException(&quot;User not found: &quot; + userId));</span>

<span class="nc" id="L82">        UserPreferences preferences = preferencesRepository.findByUserId(userId)</span>
<span class="nc" id="L83">            .orElse(createDefaultPreferences(userId));</span>

<span class="nc" id="L85">        List&lt;SkillLevel&gt; skillLevels = skillLevelRepository.findByUserId(userId);</span>

        // Get candidate content (exclude already viewed/completed)
<span class="nc" id="L88">        List&lt;Content&gt; candidates = getCandidateContent(userId);</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (candidates.isEmpty()) {</span>
<span class="nc" id="L91">            log.warn(&quot;No candidate content found for user: {}&quot;, userId);</span>
<span class="nc" id="L92">            return List.of();</span>
        }

        // Get recent content for strategy determination
<span class="nc" id="L96">        List&lt;Content&gt; recentContent = getRecentContent(userId, 5);</span>

        // Score candidates WITH behavioral profiling
<span class="nc" id="L99">        Map&lt;String, BigDecimal&gt; scores = scoringService.scoreCandidatesWithBehavioral(</span>
            candidates, userId, preferences, skillLevels, recentContent
        );

        // Apply bandit strategy for explore vs exploit
<span class="nc" id="L104">        List&lt;ScoredContent&gt; rankOrdered = applyBanditOrdering(candidates, scores, userId);</span>

        // Apply diversity algorithm
<span class="nc" id="L107">        List&lt;Content&gt; diversified = diversify(rankOrdered, limit);</span>

        // Store recommendations
<span class="nc" id="L110">        List&lt;Recommendation&gt; stored = storeRecommendations(userId, diversified, scores);</span>

<span class="nc" id="L112">        return stored.stream()</span>
<span class="nc" id="L113">            .map(RecommendationResponse::from)</span>
<span class="nc" id="L114">            .collect(Collectors.toList());</span>
    }

    /**
     * Get the next recommended content for a user
     */
    public ContentResponse getNextContent(UUID userId) {
<span class="nc" id="L121">        log.info(&quot;Getting next content for user: {}&quot;, userId);</span>

        // Check for existing pending recommendations
<span class="nc" id="L124">        Optional&lt;Recommendation&gt; existing = recommendationRepository</span>
<span class="nc" id="L125">            .findTopByUserIdOrderByScoreDesc(userId);</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (existing.isPresent()) {</span>
<span class="nc" id="L128">            Recommendation rec = existing.get();</span>
<span class="nc" id="L129">            rec.setShownAt(Instant.now());</span>
<span class="nc" id="L130">            recommendationRepository.save(rec);</span>

<span class="nc" id="L132">            Content content = rec.getContent();</span>
<span class="nc" id="L133">            log.info(&quot;Returning existing recommendation: {} for user: {}&quot;, content.getId(), userId);</span>
<span class="nc" id="L134">            return ContentResponse.from(content, rec.getScore(), rec.getReason());</span>
        }

        // Generate new recommendations
<span class="nc" id="L138">        List&lt;RecommendationResponse&gt; recommendations = getRecommendations(userId, 10);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (recommendations.isEmpty()) {</span>
<span class="nc" id="L140">            throw new NoContentAvailableException(userId);</span>
        }

        // Get the first recommendation and convert to ContentResponse
<span class="nc" id="L144">        RecommendationResponse top = recommendations.get(0);</span>
<span class="nc" id="L145">        Content content = contentRepository.findById(top.contentId())</span>
<span class="nc" id="L146">            .orElseThrow(() -&gt; new NoContentAvailableException(userId));</span>
<span class="nc" id="L147">        return ContentResponse.from(content, top.score(), top.reason());</span>
    }

    /**
     * Record feedback on a recommendation
     */
    @CacheEvict(value = &quot;recommendations&quot;, key = &quot;#userId&quot;)
    public void recordFeedback(UUID userId, String contentId, FeedbackType feedback) {
<span class="nc" id="L155">        log.info(&quot;Recording feedback for user: {}, content: {}, feedback: {}&quot;,</span>
            userId, contentId, feedback);

        // Update the recommendation with feedback
<span class="nc" id="L159">        List&lt;Recommendation&gt; recs = recommendationRepository.findByUserIdOrderByScoreDesc(userId);</span>
<span class="nc" id="L160">        recs.stream()</span>
<span class="nc" id="L161">            .filter(r -&gt; r.getContent().getId().equals(contentId))</span>
<span class="nc" id="L162">            .findFirst()</span>
<span class="nc" id="L163">            .ifPresent(rec -&gt; {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (feedback == FeedbackType.CLICKED) {</span>
<span class="nc" id="L165">                    rec.setClickedAt(Instant.now());</span>
                }
<span class="nc" id="L167">                recommendationRepository.save(rec);</span>
<span class="nc" id="L168">            });</span>

        // In a real implementation, this would update user preferences
        // and trigger re-scoring of content
<span class="nc" id="L172">    }</span>

    /**
     * Get candidate content (exclude already viewed)
     */
    private List&lt;Content&gt; getCandidateContent(UUID userId) {
        // Get all published content
<span class="nc" id="L179">        List&lt;Content&gt; allContent = contentRepository.findByStatus(Content.ContentStatus.PUBLISHED);</span>

        // Get viewed content IDs
<span class="nc" id="L182">        List&lt;String&gt; viewedContentIds = interactionRepository.findViewedContentIds(</span>
            userId,
<span class="nc" id="L184">            List.of(com.gradepath.content.analytics.model.InteractionType.VIEWED,</span>
                    com.gradepath.content.analytics.model.InteractionType.COMPLETED,
                    com.gradepath.content.analytics.model.InteractionType.SKIPPED)
        );

        // Filter out viewed content
<span class="nc" id="L190">        return allContent.stream()</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            .filter(content -&gt; !viewedContentIds.contains(content.getId()))</span>
<span class="nc" id="L192">            .collect(Collectors.toList());</span>
    }

    /**
     * Get recent content for strategy determination
     */
    private List&lt;Content&gt; getRecentContent(UUID userId, int limit) {
        // Get recent interactions and convert to content
        // For now, return empty list - would be implemented with interaction history
<span class="nc" id="L201">        return List.of();</span>
    }

    /**
     * Apply bandit ordering for explore vs exploit
     */
    private List&lt;ScoredContent&gt; applyBanditOrdering(
            List&lt;Content&gt; candidates,
            Map&lt;String, BigDecimal&gt; scores,
            UUID userId) {

        // Convert scores to double for bandit algorithm
<span class="nc" id="L213">        Map&lt;String, Double&gt; doubleScores = scores.entrySet().stream()</span>
<span class="nc" id="L214">            .collect(Collectors.toMap(</span>
                Map.Entry::getKey,
<span class="nc" id="L216">                e -&gt; e.getValue().doubleValue()</span>
            ));

        // Apply epsilon-greedy: 20% exploration, 80% exploitation
        // Use a fixed seed for reproducibility during testing
<span class="nc" id="L221">        double epsilon = 0.2;</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        boolean explore = Math.random() &lt; epsilon;</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (explore) {</span>
            // Shuffle candidates for exploration
<span class="nc" id="L226">            List&lt;Content&gt; shuffled = new ArrayList&lt;&gt;(candidates);</span>
<span class="nc" id="L227">            Collections.shuffle(shuffled);</span>
<span class="nc" id="L228">            return shuffled.stream()</span>
<span class="nc" id="L229">                .map(c -&gt; new ScoredContent(c, scores.getOrDefault(c.getId(), BigDecimal.ZERO)))</span>
<span class="nc" id="L230">                .collect(Collectors.toList());</span>
        } else {
            // Sort by score for exploitation
<span class="nc" id="L233">            List&lt;ScoredContent&gt; sorted = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            for (Content content : candidates) {</span>
<span class="nc" id="L235">                BigDecimal score = scores.getOrDefault(content.getId(), BigDecimal.valueOf(0.5));</span>
<span class="nc" id="L236">                sorted.add(new ScoredContent(content, score));</span>
<span class="nc" id="L237">            }</span>
<span class="nc" id="L238">            sorted.sort((a, b) -&gt; b.score().compareTo(a.score()));</span>
<span class="nc" id="L239">            return sorted;</span>
        }
    }

    /**
     * Apply diversity algorithm to recommendations
     */
    private List&lt;Content&gt; diversify(List&lt;ScoredContent&gt; scoredContent, int limit) {
        // Simple diversity: ensure mix of content types
<span class="nc" id="L248">        Map&lt;Content.ContentType, List&lt;Content&gt;&gt; byType = scoredContent.stream()</span>
<span class="nc" id="L249">            .map(sc -&gt; sc.content())</span>
<span class="nc" id="L250">            .collect(Collectors.groupingBy(Content::getType));</span>

<span class="nc" id="L252">        List&lt;Content&gt; diversified = new ArrayList&lt;&gt;();</span>

        // Round-robin through types to ensure diversity
<span class="nc" id="L255">        List&lt;Content.ContentType&gt; types = new ArrayList&lt;&gt;(byType.keySet());</span>
<span class="nc" id="L256">        int typeIndex = 0;</span>

<span class="nc bnc" id="L258" title="All 4 branches missed.">        while (diversified.size() &lt; limit &amp;&amp; !byType.isEmpty()) {</span>
<span class="nc" id="L259">            Content.ContentType currentType = types.get(typeIndex % types.size());</span>
<span class="nc" id="L260">            List&lt;Content&gt; typeContent = byType.get(currentType);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (!typeContent.isEmpty()) {</span>
<span class="nc" id="L263">                diversified.add(typeContent.remove(0));</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (typeContent.isEmpty()) {</span>
<span class="nc" id="L265">                    byType.remove(currentType);</span>
<span class="nc" id="L266">                    types.remove(currentType);</span>
<span class="nc" id="L267">                    typeIndex = 0;</span>
<span class="nc" id="L268">                    continue;</span>
                }
            }

<span class="nc" id="L272">            typeIndex++;</span>
<span class="nc" id="L273">        }</span>

        // If we didn't get enough, add remaining by score
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (diversified.size() &lt; limit) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (ScoredContent sc : scoredContent) {</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (!diversified.contains(sc.content())) {</span>
<span class="nc" id="L279">                    diversified.add(sc.content());</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (diversified.size() &gt;= limit) break;</span>
                }
<span class="nc" id="L282">            }</span>
        }

<span class="nc" id="L285">        return diversified;</span>
    }

    /**
     * Store recommendations in database
     */
    private List&lt;Recommendation&gt; storeRecommendations(
            UUID userId,
            List&lt;Content&gt; contents,
            Map&lt;String, BigDecimal&gt; scores) {

<span class="nc" id="L296">        User user = userRepository.getReferenceById(userId);</span>

<span class="nc" id="L298">        List&lt;Recommendation&gt; recommendations = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (Content content : contents) {</span>
<span class="nc" id="L300">            BigDecimal score = scores.get(content.getId());</span>

<span class="nc" id="L302">            Recommendation rec = Recommendation.builder()</span>
<span class="nc" id="L303">                .user(user)</span>
<span class="nc" id="L304">                .content(content)</span>
<span class="nc" id="L305">                .score(score)</span>
<span class="nc" id="L306">                .algorithm(&quot;HYBRID&quot;)</span>
<span class="nc" id="L307">                .reason(&quot;Personalized based on your preferences and learning history&quot;)</span>
<span class="nc" id="L308">                .build();</span>

            // Explicitly set createdAt to bypass Builder pattern issues
<span class="nc" id="L311">            rec.setCreatedAt(Instant.now());</span>

<span class="nc" id="L313">            recommendations.add(recommendationRepository.save(rec));</span>
<span class="nc" id="L314">        }</span>

<span class="nc" id="L316">        return recommendations;</span>
    }

    /**
     * Create default preferences
     */
    private UserPreferences createDefaultPreferences(UUID userId) {
<span class="nc" id="L323">        UserPreferences preferences = UserPreferences.builder()</span>
<span class="nc" id="L324">            .userId(userId)</span>
<span class="nc" id="L325">            .difficultyPreference(3)</span>
<span class="nc" id="L326">            .dailyTimeTargetMinutes(30)</span>
<span class="nc" id="L327">            .build();</span>
<span class="nc" id="L328">        return preferencesRepository.save(preferences);</span>
    }

    // Response DTOs
<span class="nc" id="L332">    public record RecommendationResponse(</span>
        UUID id,
        String contentId,
        String title,
        String contentType,
        Integer difficultyLevel,
        BigDecimal score,
        String reason,
        String algorithm
    ) {
        static RecommendationResponse from(Recommendation rec) {
<span class="nc" id="L343">            return new RecommendationResponse(</span>
<span class="nc" id="L344">                rec.getId(),</span>
<span class="nc" id="L345">                rec.getContent().getId(),</span>
<span class="nc" id="L346">                rec.getContent().getTitle(),</span>
<span class="nc" id="L347">                rec.getContent().getType().name(),</span>
<span class="nc" id="L348">                rec.getContent().getDifficultyLevel(),</span>
<span class="nc" id="L349">                rec.getScore(),</span>
<span class="nc" id="L350">                rec.getReason(),</span>
<span class="nc" id="L351">                rec.getAlgorithm()</span>
            );
        }
    }

<span class="nc" id="L356">    public record ContentResponse(</span>
        String id,
        String type,
        String title,
        String description,
        Integer difficultyLevel,
        Integer estimatedDurationMinutes,
        BigDecimal score,
        String reason
    ) {
        static ContentResponse from(Content content, BigDecimal score, String reason) {
<span class="nc" id="L367">            return new ContentResponse(</span>
<span class="nc" id="L368">                content.getId(),</span>
<span class="nc" id="L369">                content.getType().name(),</span>
<span class="nc" id="L370">                content.getTitle(),</span>
<span class="nc" id="L371">                content.getDescription(),</span>
<span class="nc" id="L372">                content.getDifficultyLevel(),</span>
<span class="nc" id="L373">                content.getEstimatedDurationMinutes(),</span>
                score,
                reason
            );
        }
    }

<span class="nc" id="L380">    private record ScoredContent(Content content, BigDecimal score) {}</span>

<span class="nc" id="L382">    public enum FeedbackType {</span>
<span class="nc" id="L383">        CLICKED,</span>
<span class="nc" id="L384">        DISMISSED,</span>
<span class="nc" id="L385">        BOOKMARKED</span>
    }

    public static class NoContentAvailableException extends RuntimeException {
        public NoContentAvailableException(UUID userId) {
<span class="nc" id="L390">            super(&quot;No content available for user: &quot; + userId);</span>
<span class="nc" id="L391">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>